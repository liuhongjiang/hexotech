<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>go语言学习 | Andrew&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一点体会
下面这篇博文是在看《go语言编程》书的笔记。 在看书的过程中，其实也没有对go语言进行深入的学习。仅仅是停留在对语法的简单了解。
总的来说，go语言没有它多的新东西，仅仅是将各个语言比较有特色的内容，集中到以一个语言中，而且还是基于C语言的，因为go语言的作者就是C语言的作者。哪些比较有特色的呢，例如闭包，接口，垃圾回收，还有必然语言级别支持协程。这种炒大杂烩的方式，个人感觉不可能会">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言学习">
<meta property="og:url" content="http://liuhongjiang.github.io/2013/11/25/learning-go/index.html">
<meta property="og:site_name" content="Andrew's Blog">
<meta property="og:description" content="一点体会
下面这篇博文是在看《go语言编程》书的笔记。 在看书的过程中，其实也没有对go语言进行深入的学习。仅仅是停留在对语法的简单了解。
总的来说，go语言没有它多的新东西，仅仅是将各个语言比较有特色的内容，集中到以一个语言中，而且还是基于C语言的，因为go语言的作者就是C语言的作者。哪些比较有特色的呢，例如闭包，接口，垃圾回收，还有必然语言级别支持协程。这种炒大杂烩的方式，个人感觉不可能会">
<meta property="og:updated_time" content="2015-07-23T05:46:28.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go语言学习">
<meta name="twitter:description" content="一点体会
下面这篇博文是在看《go语言编程》书的笔记。 在看书的过程中，其实也没有对go语言进行深入的学习。仅仅是停留在对语法的简单了解。
总的来说，go语言没有它多的新东西，仅仅是将各个语言比较有特色的内容，集中到以一个语言中，而且还是基于C语言的，因为go语言的作者就是C语言的作者。哪些比较有特色的呢，例如闭包，接口，垃圾回收，还有必然语言级别支持协程。这种炒大杂烩的方式，个人感觉不可能会">
  
    <link rel="alternative" href="/atom.xml" title="Andrew&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/hexotech/images/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/hexotech/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/hexotech/" id="logo">Andrew&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/hexotech/">Home</a>
        
          <a class="main-nav-link" href="/hexotech/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuhongjiang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-learning-go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexotech/2013/11/25/learning-go/" class="article-date">
  <time datetime="2013-11-25T10:28:00.000Z" itemprop="datePublished">2013-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexotech/categories/Language/">Language</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      go语言学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一点体会">一点体会</h2>
<p>下面这篇博文是在看<a href="http://book.douban.com/subject/11577300/" target="_blank" rel="external">《go语言编程》</a>书的笔记。 在看书的过程中，其实也没有对go语言进行深入的学习。仅仅是停留在对语法的简单了解。</p>
<p>总的来说，go语言没有它多的新东西，仅仅是将各个语言比较有特色的内容，集中到以一个语言中，而且还是基于C语言的，因为go语言的作者就是C语言的作者。哪些比较有特色的呢，例如闭包，接口，垃圾回收，还有必然语言级别支持协程。这种炒大杂烩的方式，个人感觉不可能会成功。只不过go语言已一个比较强大的干爹google，所有才多多少少掀起了几个波浪。</p>
<p>很有意思的一件事情是，虽然这个语言生在美国，生在google，但是目前go语言的社区最活跃的，还是我们中国的屌丝程序员。我认为这是一件极好的事情，说明了我们中国在IT方面对新事物的开明态度和勇于追逐，虽然成功可能不在go语言，但是有这种态度，终会有所作为。</p>
<h2 id="go语言简介">go语言简介</h2>
<p>go语言是google推出的一个可以提高并发编程的语言，它着不同一般的背景。</p>
<ul>
<li>回溯至1969 年, 肯·汤普逊（Ken Thompson）和丹尼斯·里奇（Dennis Ritchie ）在贝尔实验室的计算科学研究中心里开发出了Unix ，还因为开发Unix而衍生——C语言。</li>
<li>80年代，开始Plan 9 的操作系统研究项目，解决Unix 中的一些问题, 又演变出了Inferno 的项目分支，以及一个名为Limbo 的编程语言</li>
<li>Limbo是用于开发运行在小型计算机上的分布式应用的编程语言，它支持模块化编程，编译期和运行时的强类型检查，进程内基于具有类型的通信通道，原子性垃圾收集和简单的抽象数据类型。它被设计为：即便是在没有硬件内存保护的小型设备上，也能安全运行。</li>
<li>Limbo 语言被认为是Go语言的前身，不仅仅因为是同一批人设计的语言，而是Go语言确实从Limbo 语言中继承了众多优秀的特性。</li>
<li>贝尔实验室后来经历了多次的动荡，包括肯·汤普逊在内的Plan 9 项目原班人马加入了Google 。在Google ，他们创造了Go语言。</li>
<li>2007 年9月，Go语言还是这帮大牛的20% 自由时间的实验项目</li>
<li>2008 年5月，Google 发现了Go语言的巨大潜力，从而开始全力支持这个项目</li>
<li>2009年11 月，发布第一个版本在</li>
<li>2012年3月28 日，发布第一个正式版本</li>
</ul>
<h2 id="go语言特性">go语言特性</h2>
<ul>
<li>自动垃圾回收</li>
<li>更丰富的内置类型</li>
<li>函数多返回值</li>
<li>错误处理</li>
<li>匿名函数和闭包</li>
<li>类型和接口</li>
<li>并发编程</li>
<li>反射</li>
<li>语言交互性 (Cgo, C语言库)</li>
</ul>
<a id="more"></a>
<h2 id="go的工具">go的工具</h2>
<ul>
<li>编辑器
<ul>
<li>文本编辑工具gedit（Linux）/Notepad++ （Windows）/Fraise （Mac OS X）</li>
<li>安装了GoClipse 插件的Eclipse ，集成性做得很好；</li>
<li>Vim/Emacs，万能开发工具；</li>
<li>LiteIDE，一款专为Go语言开发的集成开发环境。</li>
</ul></li>
<li>工程管理
<ul>
<li>Go命令行工具</li>
</ul></li>
<li>调试
<ul>
<li>FMT 输出日志/gdb</li>
</ul></li>
</ul>
<h1 id="语言">语言</h1>
<h2 id="变量">变量</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  v1 <span class="typename">int</span>  </span><br><span class="line"><span class="keyword">var</span>  v2 <span class="typename">string</span>  </span><br><span class="line"><span class="keyword">var</span>  v3 [<span class="number">10</span>] <span class="typename">int</span>     <span class="comment">//  数组 </span></span><br><span class="line"><span class="keyword">var</span>  v4 [] <span class="typename">int</span>      <span class="comment">//  数组切片 </span></span><br><span class="line"><span class="keyword">var</span> v5 <span class="keyword">struct</span> &#123; </span><br><span class="line">    f  <span class="typename">int</span>  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span>  v6 *<span class="typename">int</span>       <span class="comment">//  指针 </span></span><br><span class="line"><span class="keyword">var</span>  v7 <span class="keyword">map</span> [ <span class="typename">string</span> ] <span class="typename">int</span>  <span class="comment">// map ，key 为string 类型，value 为int 类型 </span></span><br><span class="line"><span class="keyword">var</span>  v8 <span class="keyword">func</span>(a  <span class="typename">int</span> ) <span class="typename">int</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1  <span class="typename">int</span>  = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="number">10</span>  <span class="comment">//  编译器自动推导出v2 的类型 </span></span><br><span class="line">v3 := <span class="number">10</span>  <span class="comment">// 编译器自动推导出v3 的类型</span></span><br></pre></td></tr></table></figure>
<p>Go语言也引入了另一个C和C++ 中没有的符号（冒号和等号的组合:=），用于明确表达同时进行变量声明和初始化的工作。</p>
<p>go支持直接交换值</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span>  v10 int  </span><br><span class="line">v10 = <span class="number">123</span> </span><br><span class="line"><span class="tag">i</span>, j = j, <span class="tag">i</span>     <span class="comment">//交换值</span></span><br></pre></td></tr></table></figure>
<h2 id="常量">常量</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">12</span>                 <span class="comment">// 无类型常量</span></span><br><span class="line"><span class="number">3.14159265358979323846</span> <span class="comment">//  浮点类型的常量 </span></span><br><span class="line"><span class="number">3.2</span>+<span class="number">12</span>i      <span class="comment">// 复数类型的常量 </span></span><br><span class="line"><span class="literal">true</span>      <span class="comment">//  布尔类型的常量 </span></span><br><span class="line"><span class="string">"foo"</span>     <span class="comment">//  字符串常量</span></span><br></pre></td></tr></table></figure>
<p>go语言的数字类型有： <code>int</code>、<code>uint</code>、<code>int32</code>、<code>int64</code>、<code>float32</code>、<code>float64</code>、<code>complex64</code>、<code>complex128</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi float64 = <span class="number">3.14159265358979323846</span>  </span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span>             <span class="comment">// 无类型浮点常量 </span></span><br><span class="line"><span class="keyword">const</span>  (  </span><br><span class="line">    size int64 = <span class="number">1024</span> </span><br><span class="line">    eof = -<span class="number">1</span>                <span class="comment">//  无类型整型常量 </span></span><br><span class="line">)  </span><br><span class="line"><span class="keyword">const</span> u, v  float32 = <span class="number">0</span>, <span class="number">3</span>    <span class="comment">// u = 0.0, v = 3.0，常量的多重赋值 </span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">"foo"</span>   <span class="comment">// a = 3, b = 4, c = "foo",  无类型整型和字符串常量</span></span><br></pre></td></tr></table></figure>
<h2 id="类型">类型</h2>
<ul>
<li>布尔类型：bool</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">bool</span> </span><br><span class="line">v1 = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>整型：int8、byte、int16 、int 、uint、uintptr等。</li>
</ul>
<p>go语言支持位运算</p>
<p>且有一个特殊类型：uintptr: uintptr is an integer type that is large enough to hold the bit pattern of any pointer.</p>
<ul>
<li>浮点类型：float32、float64。</li>
<li>复数类型：complex64、complex128。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var value1 complex64       <span class="comment">//  由2 个float32构成的复数类型 </span></span><br><span class="line">value1 = <span class="number">3.2</span> + <span class="number">12</span>i </span><br><span class="line">value2 := <span class="number">3.2</span> + <span class="number">12</span>i        <span class="comment">// value2 是complex128类型 </span></span><br><span class="line">value3 := <span class="keyword">complex</span>(<span class="number">3.2</span>, <span class="number">12</span>)  <span class="comment">// value3结果同 value2</span></span><br></pre></td></tr></table></figure>
<p>对于一个复数z = complex(x, y) ，就可以通过Go语言内置函数real(z)获得该复数的实部，也就是x，通过imag(z)获得该复数的虚部，也就是y</p>
<ul>
<li>字符串：string。 Go编译器支持UTF-8 的源代码文件格式</li>
<li>字符类型：rune。</li>
<li>错误类型：error 。</li>
</ul>
<p>此外，Go语言也支持以下这些复合类型： * 指针（pointer ） * 数组（array）</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[32]byte       //  长度为32 的数组，每个元素为一个字节 </span><br><span class="line">[2*N]  struct  &#123; x, y  int32 &#125; //  复杂类型数组 </span><br><span class="line">[1000]*float64    //  指针数组 </span><br><span class="line">[<span class="link_label">3</span>][<span class="link_reference">5</span>] int      //  二维数组 </span><br><span class="line">[<span class="link_label">2</span>][<span class="link_reference">2</span>][<span class="link_label">2</span>]float64    //  等同于[<span class="link_label">2</span>](<span class="link_url">[2]([2]float64</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>切片（slice ） <code>myArray[:5]</code></li>
<li>字典（map）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  myMap <span class="keyword">map</span> [ <span class="typename">string</span> ] PersonInfo</span><br><span class="line"><span class="comment">// myMap是声明的map 变量名，string是键的类型，PersonInfo则是其中所存放的值类型。</span></span><br><span class="line">myMap =  <span class="built_in">make</span>( <span class="keyword">map</span> [ <span class="typename">string</span> ] PersonInfo)</span><br><span class="line">myMap =  <span class="keyword">map</span> [ <span class="typename">string</span> ] PersonInfo&#123; </span><br><span class="line">	<span class="string">"1234"</span>: PersonInfo&#123;<span class="string">"1"</span>, <span class="string">"Jack"</span>, <span class="string">"Room 101,..."</span>&#125;, </span><br><span class="line">&#125;</span><br><span class="line">myMap[<span class="string">"1234"</span>] = PersonInfo&#123;<span class="string">"1"</span>, <span class="string">"Jack"</span>, <span class="string">"Room 101,..."</span>&#125;</span><br><span class="line"><span class="built_in">delete</span>(myMap, <span class="string">"1234"</span>)</span><br><span class="line">value, ok := myMap[<span class="string">"1234"</span>]  </span><br><span class="line"><span class="keyword">if</span> ok &#123; <span class="comment">// 找到了 </span></span><br><span class="line">	<span class="comment">// 处理找到的value  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通道（chan ） channel是Go语言在语言级别提供的goroutine 间的通信方式。我们可以使用channel在两个或多个goroutine 之间传递消息。channel是进程内的通信方式，因此通过channel传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  ch <span class="keyword">chan</span> <span class="typename">int</span></span><br><span class="line">ch :=  <span class="built_in">make</span>( <span class="keyword">chan</span> <span class="typename">int</span> )</span><br><span class="line">ch &lt;- value</span><br><span class="line">向channel写入数据通常会导致程序阻塞，直到有其他goroutine 从这个channel中读取数据。从channel中读取数据的语法是</span><br><span class="line">value := &lt;-ch</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体（struct）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect  <span class="keyword">struct</span>  &#123; </span><br><span class="line">    x, y <span class="typename">float64</span> </span><br><span class="line">    width, height  <span class="typename">float64</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口（interface ）</li>
<li>流程控制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt; <span class="number">5</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>  i &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">        fmt.Printf(<span class="string">"0"</span>) </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">        fmt.Printf(<span class="string">"1"</span>) </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">         fallthrough </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">        fmt.Printf(<span class="string">"3"</span>) </span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>: </span><br><span class="line">        fmt.Printf(<span class="string">"4, 5, 6"</span>) </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        fmt.Printf(<span class="string">"Default"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的switch语句里面没有break语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span>  i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; </span><br><span class="line">    sum += i </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">a := []<span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; </span><br><span class="line"><span class="keyword">for</span>  i, j := <span class="number">0</span>, len(a) – <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j – <span class="number">1</span> &#123; </span><br><span class="line">    a[i], a[j] = a[j], a[i] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>且go语言包含goto语句</p>
<ul>
<li>函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mymath </span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> Add(a <span class="typename">int</span> , b <span class="typename">int</span> ) (ret <span class="typename">int</span> , err error) &#123; </span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> &#123; <span class="comment">//  假设这个函数只支持两个非负数字的加法 </span></span><br><span class="line">        err= errors.New(<span class="string">"Should be non-negative numbers!"</span>) </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>  a + b,  <span class="constant">nil</span>  <span class="comment">//  支持多重返回值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不定参数类型</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(<span class="keyword">args</span> ... int ) &#123; </span><br><span class="line">    <span class="keyword">for</span>  _, arg :=  <span class="keyword">range</span> <span class="keyword">args</span> &#123; </span><br><span class="line">		fmt.Println(arg) </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">n</span>, _ := f.<span class="keyword">Read</span>(buf)</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span>  ( </span><br><span class="line">	<span class="string">"fmt"</span> </span><br><span class="line">)   </span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">var</span>  j  int  = <span class="number">5</span> </span><br><span class="line"> </span><br><span class="line">    a := <span class="func"><span class="keyword">func</span><span class="params">()</span></span>( <span class="func"><span class="keyword">func</span><span class="params">()</span></span>) &#123; </span><br><span class="line">         <span class="keyword">var</span>  i  int  = <span class="number">10</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="func"><span class="keyword">func</span> <span class="params">()</span></span> &#123; </span><br><span class="line">            fmt.<span class="type">Printf</span>(<span class="string">"i, j: %d, %d\n"</span>, i, j) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;() </span><br><span class="line"> </span><br><span class="line">    a() </span><br><span class="line"> </span><br><span class="line">    j *= <span class="number">2</span> </span><br><span class="line"> </span><br><span class="line">    a() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>defer 解决释放资源的问题, 可以通过defer字段实现资源的自动释放</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dst, src string ) (w int64, <span class="keyword">err</span> <span class="keyword">error</span>) &#123; </span><br><span class="line">    srcFile, <span class="keyword">err</span> := os.<span class="keyword">Open</span>(src) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> !=  nil  &#123; </span><br><span class="line">         <span class="keyword">return</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    defer srcFile.<span class="keyword">Close</span>() </span><br><span class="line"> </span><br><span class="line">    dstFile, <span class="keyword">err</span> := os.Create(dstName) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> !=  nil  &#123; </span><br><span class="line">         <span class="keyword">return</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    defer dstFile.<span class="keyword">Close</span>() </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>  io.<span class="keyword">Copy</span>(dstFile, srcFile)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>panic()和recover()</li>
</ul>
<p>panic()函数时，正常的函数执行流程将立即终止，但函数中之前使用defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行panic流程，直至所属的goroutine 中所有正在执行的函数被终止。</p>
<p>recover()函数用于终止错误处理流程。</p>
<h2 id="面向对象">面向对象</h2>
<p>对于面向对象编程的支持Go 语言设计得非常简洁而优雅。简洁之处在于，Go语言并没有沿袭传统面向对象编程中的诸多概念，比如继承、虚函数、构造函数和析构函数、隐藏的this指针等。优雅之处在于，Go语言对面向对象编程的支持是语言类型系统中的天然组成部分。整个类型系统通过接口串联，浑然一体。我们在本章中将一一解释这些特性。 类型 在Go语言中，你可以给任意类型（包括内置类型，但不包括指针类型）添加相应的方法，例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Integer</span> <span class="built_in">int</span>  </span><br><span class="line"> </span><br><span class="line">func (a <span class="type">Integer</span>) Less(b <span class="type">Integer</span>) bool &#123; </span><br><span class="line">	<span class="keyword">return</span>  a &lt; b </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var  a <span class="type">Integer</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">if</span> a.Less(<span class="number">2</span>) &#123; </span><br><span class="line">	<span class="keyword">fmt</span>.Println(a, <span class="string">"Less 2"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你需要修改对象的时候，才必须用指针。它不是Go语言的约束，而是一种自然约束。 举个例子：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span> &#123; </span></span><br><span class="line">    *a += b </span><br><span class="line">&#125;</span><br><span class="line">a.Add(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>值语义和引用语义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var  a = [<span class="number">3</span>] <span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line">var  b = a </span><br><span class="line">b[<span class="number">1</span>]++ </span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></table></figure>
<p>Go语言中的大多数类型都基于值语义</p>
<p><code>基本类型</code>：如byte、int 、bool、float32、float64和string等；</p>
<p><code>复合类型</code>：如数组（array）、结构体（struct）和指针（pointer ）等。</p>
<p>Go语言中有4个类型比较特别，看起来像引用类型</p>
<p><code>数组切片</code>：指向数组（array）的一个区间。</p>
<p><code>map</code>：极其常见的数据结构，提供键值查询能力。</p>
<p><code>channel</code>：执行体（goroutine ）间的通信设施。</p>
<p><code>接口（interface ）</code>：对一组满足某个契约的类型的抽象。</p>
<ul>
<li>结构体</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Rect  <span class="keyword">struct</span>  &#123; </span><br><span class="line">    x, y float64 </span><br><span class="line">    width, height  float64 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">rect1 := <span class="keyword">new</span> (Rect) </span><br><span class="line">rect2 := &amp;Rect&#123;&#125; </span><br><span class="line">rect3 := &amp;Rect&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>&#125; </span><br><span class="line">rect4 := &amp;Rect&#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名组合：</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">type</span> <span class="keyword">Base </span> <span class="keyword">struct </span> &#123; </span><br><span class="line">    Name <span class="keyword">string </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="label">func</span> (<span class="keyword">base </span>*<span class="keyword">Base) </span><span class="keyword">baseFoo() </span>&#123; ... &#125; </span><br><span class="line"><span class="label">func</span> (<span class="keyword">base </span>*<span class="keyword">Base) </span><span class="keyword">baseBar() </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="label">type</span> Foo <span class="keyword">struct </span> &#123; </span><br><span class="line">    <span class="keyword">Base </span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">func</span> (foo *Foo) <span class="keyword">Bar() </span>&#123; </span><br><span class="line">    foo.<span class="keyword">Base.baseBar() </span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母开头</p>
<ul>
<li>接口</li>
</ul>
<p>非侵入式接口: 将对象实例赋值给接口；将一个接口赋值给另一个接口。</p>
<p>我们定义一个Integer类型的对象实例，怎么将其赋值给LessAdder</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Integer</span> <span class="built_in">int</span>  </span><br><span class="line"> </span><br><span class="line">func (a <span class="type">Integer</span>) Less(b <span class="type">Integer</span>) bool &#123; </span><br><span class="line">    <span class="keyword">return</span>  a &lt; b </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">func (a *<span class="type">Integer</span>) Add(b <span class="type">Integer</span>) &#123; </span><br><span class="line">    *a += b </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LessAdder  <span class="keyword">interface</span> &#123; </span><br><span class="line">    Less(b <span class="type">Integer</span>) bool </span><br><span class="line">    Add(b <span class="type">Integer</span>) </span><br><span class="line">&#125;</span><br><span class="line">var  a <span class="type">Integer</span> = <span class="number">1</span> </span><br><span class="line">var  b LessAdder = &amp;a</span><br></pre></td></tr></table></figure>
<p>下面的例子，定义了两个不同的包：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package <span class="keyword">one</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> ReadWriter interface &#123; </span><br><span class="line">    <span class="keyword">Read</span>(buf []byte) (<span class="keyword">n</span> int , <span class="keyword">err</span> <span class="keyword">error</span>) </span><br><span class="line">    Write(buf [] byte) (<span class="keyword">n</span> int , <span class="keyword">err</span> <span class="keyword">error</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package <span class="keyword">two</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> IStream interface &#123; </span><br><span class="line">    Write(buf [] byte) (<span class="keyword">n</span> int , <span class="keyword">err</span> <span class="keyword">error</span>) </span><br><span class="line">    <span class="keyword">Read</span>(buf []byte) (<span class="keyword">n</span> int , <span class="keyword">err</span> <span class="keyword">error</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现了one.ReadWriter接口的类，均实现了two.IStream ；</p>
<ol style="list-style-type: decimal">
<li>任何one.ReadWriter接口对象可赋值给two.IStream ，反之亦然；</li>
<li>在任何地方使用one.ReadWriter接口与使用two.IStream 并无差异。</li>
</ol>
<p>以下这些代码可编译通过：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span>  file1 two<span class="class">.IStream</span> =  new (File) </span><br><span class="line"><span class="tag">var</span>  file2 one<span class="class">.ReadWriter</span> = file1 </span><br><span class="line"><span class="tag">var</span>  file3 two<span class="class">.IStream</span> = file2</span><br></pre></td></tr></table></figure>
<p>接口查询：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function_or_atom">if</span> <span class="function_or_atom">file5</span>, <span class="ok">ok</span> := <span class="function_or_atom">file1</span>.(<span class="function_or_atom">two</span>.<span class="variable">IStream</span>); <span class="ok">ok</span> &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Any 类型</li>
</ul>
<p>由于Go语言中任何对象实例都满足空接口interface{}，所以 interface{} 看起来像是可 以指向任何对象的Any 类型，如下：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var  v1 <span class="class"><span class="keyword">interface</span>&#123;</span>&#125; = <span class="number">1</span>       //  将int 类型赋值给<span class="class"><span class="keyword">interface</span>&#123;</span>&#125; </span><br><span class="line">var  v2 <span class="class"><span class="keyword">interface</span>&#123;</span>&#125; = <span class="string">"abc"</span>   //  将string类型赋值给<span class="class"><span class="keyword">interface</span>&#123;</span>&#125; </span><br><span class="line">var  v3 <span class="class"><span class="keyword">interface</span>&#123;</span>&#125; = &amp;v2     //  将*<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;类型赋值给<span class="class"><span class="keyword">interface</span>&#123;</span>&#125; </span><br><span class="line">var  v4 <span class="class"><span class="keyword">interface</span>&#123;</span>&#125; = <span class="class"><span class="keyword">struct</span> &#123;</span> X int  &#125;&#123;<span class="number">1</span>&#125; </span><br><span class="line">var  v5 <span class="class"><span class="keyword">interface</span>&#123;</span>&#125; = &amp; <span class="class"><span class="keyword">struct</span> &#123;</span> X int  &#125;&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>fmt包中的Print定义，可以看出any类型的优势。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...interface&#123;&#125;)</span> <span class="params">(n int, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(fmt string , args ...interface&#123;&#125;)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(args ...interface&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="并发编程">并发编程</h2>
<p>并发编程的模型一般有：</p>
<ul>
<li>多进程</li>
<li>多线程</li>
<li>基于回调的非阻塞/ 异步IO</li>
<li>协程</li>
</ul>
<p><a href="http://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="external">协程</a><a href="http://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">(coroutine)</a>本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器。目前，原生支持协程的语言还很少。</p>
<p>子例程(线程)的起始处是惟一的入口点，一旦退出即完成了子程序的执行，子程序的一个实例只会返回一次。 协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。 协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。</p>
<p>以下是协程的一段伪代码</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">生产者协程</span><br><span class="line">   <span class="keyword">loop</span></span><br><span class="line">       <span class="keyword">while</span> q <span class="keyword">is</span> <span class="keyword">not</span> full</span><br><span class="line">           <span class="keyword">create</span> some <span class="keyword">new</span> items</span><br><span class="line">           <span class="keyword">add</span> the items <span class="keyword">to</span> q</span><br><span class="line">       <span class="keyword">yield</span> <span class="keyword">to</span> consume</span><br><span class="line">消费者协程</span><br><span class="line">   <span class="keyword">loop</span></span><br><span class="line">       <span class="keyword">while</span> q <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">empty</span></span><br><span class="line">           <span class="keyword">remove</span> some items <span class="keyword">from</span> q</span><br><span class="line">           use the items</span><br><span class="line">       <span class="keyword">yield</span> <span class="keyword">to</span> produce</span><br></pre></td></tr></table></figure>
<p>一个python的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Wen Chuan'</span>,</span><br><span class="line">    m = <span class="keyword">yield</span> <span class="number">5</span>  <span class="comment"># Fighting!</span></span><br><span class="line">    <span class="keyword">print</span> m</span><br><span class="line">    d = <span class="keyword">yield</span> <span class="number">12</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'We are together!'</span></span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">m = c.next()  <span class="comment">#m 获取了yield 5 的参数值 5</span></span><br><span class="line">d = c.send(<span class="string">'Fighting!'</span>)  <span class="comment">#d 获取了yield 12 的参数值12</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'We will never forget the date'</span>, m, <span class="string">'.'</span>, d</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wen Chuan Fighting!</span><br><span class="line">We will never forget the date <span class="number">5</span> . <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Go 语言在语言级别支持轻量级线程，叫goroutine 。 一个函数调用前加上go关键字，这次调用就会在一个新的goroutine 中并发执行。当被调用的函数返回时，这个goroutine 也自动结束了。需要注意的是，如果这个函数有返回值，那么这个返回值会被丢弃。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main </span><br><span class="line"> </span><br><span class="line">import  <span class="string">"fmt"</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y int )</span> &#123; </span></span><br><span class="line">    z := x + y </span><br><span class="line">    fmt.Println(z)  </span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span> &#123; </span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span><span class="comment">; i &lt; 10; i++ &#123; </span></span><br><span class="line"> 		go Add(i, i) </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码源文件</p>
<figure class="highlight go"><figcaption><span>协程示例1</span><a href="/hexotech/code/2013/go/goroutine1.go">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Add(x, y <span class="typename">int</span>) {</span><br><span class="line">	z := x + y</span><br><span class="line">	fmt.Println(z)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">go</span> Add(i, i)</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line">	fmt.Println(<span class="string">"finished"</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><figcaption><span>协程示例2</span><a href="/hexotech/code/2013/go/goroutine1.go">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Add(x, y <span class="typename">int</span>) {</span><br><span class="line">	z := x + y</span><br><span class="line">	fmt.Println(z)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">go</span> Add(i, i)</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line">	fmt.Println(<span class="string">"finished"</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>channel</li>
</ul>
<p>channel是Go语言在语言级别提供的goroutine 间的通信方式。我们可以使用channel在两个或多个goroutine 之间传递消息。channel是进程内的通信方式，因此通过channel传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。</p>
<p>channel是类型相关的。也就是说，一个channel只能传递一种类型的值，这个类型需要在声明channel时指定。如果对Unix 管道有所了解的话，就不难理解channel，可以将其认为是一种类型安全的管道。</p>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  chanName <span class="keyword">chan</span> ElementType</span><br><span class="line"><span class="keyword">var</span>  ch <span class="keyword">chan</span> <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span>  m  <span class="keyword">map</span> [ <span class="typename">string</span> ] <span class="keyword">chan</span> <span class="typename">bool</span></span><br><span class="line">ch :=  <span class="built_in">make</span>( <span class="keyword">chan</span> <span class="typename">int</span> )</span><br></pre></td></tr></table></figure>
<p>在channel的用法中，最常见的包括写入和读出。将一个数据写入（发送）至channel的语法很直观，如下：</p>
<pre><code>ch &lt;- value </code></pre>
<p>向channel写入数据通常会导致程序阻塞，直到有其他goroutine 从这个channel中读取数据。从channel中读取数据的语法是</p>
<pre><code>value := &lt;-ch  </code></pre>
<p>如果channel之前没有写入数据，那么从channel中读取数据也会导致程序阻塞，直到channel中被写入数据为止。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Select</span></span><br><span class="line"><span class="title">select</span>  &#123; </span><br><span class="line">	<span class="keyword">case</span> &lt;-chan1: </span><br><span class="line">	// 如果chan1成功读到数据，则进行该<span class="keyword">case</span>处理语句 </span><br><span class="line"> 	<span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>: </span><br><span class="line">	// 如果成功向chan2 写入数据，则进行该<span class="keyword">case</span>处理语句 </span><br><span class="line"> 	<span class="default"><span class="keyword">default</span>: </span></span><br><span class="line">	// 如果上面都没有成功，则进入<span class="default"><span class="keyword">default</span>处理流程 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>缓冲机制</li>
</ul>
<p>给channel带上缓冲，从而达到消息队列的效果。 要创建一个带缓冲的channel，其实也非常容易：</p>
<pre><code>c := make( chan int , 1024)</code></pre>
<p>从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可以使用range关键来实现更为简便的循环读取：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">for</span>  <span class="rule"><span class="attribute">i </span>:<span class="value">=  range c &#123; </span><br><span class="line">    fmt.<span class="function">Println</span>(<span class="string">"Received:"</span>, i) </span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，在Go语言中channel本身也是一个原生类型，与map之类的类型地位一样，因此channel本身在定义后也可以通过channel来传递。</p>
<ul>
<li>超时机制</li>
</ul>
<p>Go语言没有提供直接的超时处理机制，但我们可以利用select机制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  首先，我们实现并执行一个匿名的超时等待函数 </span></span><br><span class="line">timeout :=  <span class="built_in">make</span>( <span class="keyword">chan</span> <span class="typename">bool</span>, <span class="number">1</span>) </span><br><span class="line"><span class="keyword">go</span> <span class="keyword">func</span>() &#123; </span><br><span class="line">    time.Sleep(<span class="number">1e9</span>) <span class="comment">//  等待1秒钟 </span></span><br><span class="line">    timeout &lt;- <span class="constant">true</span> </span><br><span class="line">&#125;() </span><br><span class="line"> </span><br><span class="line"><span class="comment">//  然后我们把timeout这个channel利用起来 </span></span><br><span class="line"><span class="keyword">select</span>  &#123; </span><br><span class="line">	<span class="keyword">case</span> &lt;-ch: </span><br><span class="line">	<span class="comment">// 从ch中读取到数据 </span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timeout: </span><br><span class="line">	<span class="comment">// 一直没有从ch中读取到数据，但从timeout中读取到了数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单向channel</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  ch1 <span class="keyword">chan</span> <span class="typename">int</span>  <span class="comment">// ch1 是一个正常的channel，不是单向的 </span></span><br><span class="line"><span class="keyword">var</span>  ch2 <span class="keyword">chan</span>&lt;-  <span class="typename">float64</span><span class="comment">// ch2 是单向channel，只用于写float64数据 </span></span><br><span class="line"><span class="keyword">var</span>  ch3 &lt;-<span class="keyword">chan</span> <span class="typename">int</span>  <span class="comment">// ch3 是单向channel，只用于读取int 数据</span></span><br></pre></td></tr></table></figure>
<p>只有在介绍了单向channel的概念后，读者才会明白类型转换对于channel的意义：就是在单向channel和双向channel之间进行转换。示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>( <span class="keyword">chan</span> <span class="typename">int</span> ) </span><br><span class="line">ch5 := &lt;-<span class="keyword">chan</span> <span class="typename">int</span> (ch4) <span class="comment">// ch5就是一个单向的读取channel </span></span><br><span class="line">ch6 := <span class="keyword">chan</span>&lt;-  <span class="typename">int</span> (ch4) <span class="comment">// ch6  是一个单向的写入channel</span></span><br></pre></td></tr></table></figure>
<p>关闭channel</p>
<pre><code>close(ch)</code></pre>
<p>关闭后：</p>
<pre><code>x, ok := &lt;-ch </code></pre>
<p>这个用法与map 中的按键获取value的过程比较类似，只需要看第二个bool返回值即可，如果返回值是false 则表示ch已经被关闭。</p>
<p>多核并行化，让出时间片</p>
<figure class="highlight go"><figcaption><span>多核并行示例 </span><a href="/hexotech/code/2013/go/parallel.go">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="typename">float64</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//  分配给每个CPU 的计算任务 </span></span><br><span class="line"><span class="keyword">func</span> (v Vector) DoSome(i, n <span class="typename">int</span> , u Vector, c <span class="keyword">chan</span> <span class="typename">int</span> ) { </span><br><span class="line"> <span class="keyword">for</span> ; i &lt; n; i++ { </span><br><span class="line">         v[i] += u.Op(v[i]) </span><br><span class="line">     } </span><br><span class="line">     c &lt;- <span class="number">1</span>          <span class="comment">//  发信号告诉任务管理者我已经计算完成了 </span></span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> NCPU = <span class="number">16</span>      <span class="comment">// 假设总共有16 核 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> (v Vector) DoAll(u Vector) { </span><br><span class="line"> </span><br><span class="line">    c := <span class="built_in">make</span>( <span class="keyword">chan</span> <span class="typename">int</span> , NCPU)  <span class="comment">// 用于接收每个CPU 的任务完成信号 </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ { </span><br><span class="line">  <span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/NCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/NCPU, u, c) </span><br><span class="line">    } </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 等待所有CPU 的任务完成 </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ { </span><br><span class="line">    &lt;-c    <span class="comment">//  获取到一个数据，表示一个CPU 计算完成了 </span></span><br><span class="line">    } </span><br><span class="line"> <span class="comment">// 到这里表示所有计算已经结束 </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>同步</li>
</ul>
<p>Go语言包中的sync包提供了两种锁类型：sync.Mutex和sync.RWMutex。 RWMutex相对友好些，是经典的单写多读模型</p>
<p>Go语言提供了一个Once类型来保证全局的唯一性操作，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a string  </span><br><span class="line"><span class="keyword">var</span> once sync.<span class="type">Once</span>   </span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123; </span><br><span class="line"> 	a = <span class="string">"hello, world"</span> </span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123; </span><br><span class="line">	once.<span class="type">Do</span>(setup) </span><br><span class="line">	<span class="built_in">print</span>(a)  </span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123; </span><br><span class="line">	go doprint() </span><br><span class="line">	go doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goroutine 和channel 是支撑起Go语言的并发模型的基石，让Go语言在如今集群化与多核化的时代成为一道极为亮丽的风景</p>
<p>最后，看书的过程中，写的关于一些简单的go语言的例子，在<a href="https://github.com/liuhongjiang/tech/tree/source/source/code/2013/go" target="_blank" rel="external">这里</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuhongjiang.github.io/hexotech/2013/11/25/learning-go/" data-id="cifhng2970019cgi4qhgwfle0" class="article-share-link">Share</a>
      
        <a href="http://liuhongjiang.github.io/hexotech/2013/11/25/learning-go/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/hexotech/2014/05/16/rules/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          规则
        
      </div>
    </a>
  
  
    <a href="/hexotech/2013/08/18/tree/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构--树</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/3rd-nbsp-tools/">3rd&nbsp;tools</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/Algorithm/">Algorithm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/C-C/">C/C++</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/Data-nbsp-structure/">Data&nbsp;structure</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/Fuck-nbsp-GFW/">Fuck&nbsp;GFW</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/Language/">Language</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/Machine-nbsp-Learning/">Machine&nbsp;Learning</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/Vi/">Vi</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/git/">git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/hadoop/">hadoop</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/javascript/">javascript</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/math/">math</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/octopress/">octopress</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/paper/">paper</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexotech/categories/sqlite/">sqlite</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2015/09/">September 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2015/08/">August 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2015/05/">May 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2015/04/">April 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2014/05/">May 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2013/11/">November 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2013/08/">August 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2013/02/">February 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2013/01/">January 2013</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2012/12/">December 2012</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexotech/archives/2012/11/">November 2012</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hexotech/2015/09/30/vpn-server/">vpn server 搭建</a>
          </li>
        
          <li>
            <a href="/hexotech/2015/09/30/tmux/">tmux</a>
          </li>
        
          <li>
            <a href="/hexotech/2015/09/30/underscore-template/">underscore template</a>
          </li>
        
          <li>
            <a href="/hexotech/2015/09/22/Docker-beginning/">初识Docker</a>
          </li>
        
          <li>
            <a href="/hexotech/2015/09/07/Authentication-Anomaly-Detection-A-Case-Study-On-A-Virtual-Private-Network/">Authentication Anomaly Detection: A Case Study On A Virtual Private Network</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Andrew Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/hexotech/" class="mobile-nav-link">Home</a>
  
    <a href="/hexotech/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'andrewliu117';
  
  var disqus_url = 'http://liuhongjiang.github.io/hexotech/2013/11/25/learning-go/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/hexotech/js/jquery-2.1.4.min.js" type="text/javascript"></script>

<!--<script type="text/x-mathjax-config">-->
<!--MathJax.Hub.Config({-->
  <!--tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}-->
<!--});-->
<!--</script>-->
<!--<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<!--</script>-->


  <link rel="stylesheet" href="/hexotech/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/hexotech/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/hexotech/js/script.js" type="text/javascript"></script>



  </div>
</body>
</html>